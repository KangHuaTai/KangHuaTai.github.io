# 继 承
好处：

    1：提高了代码的复用性。
    2：让类与类之间产生了关系，提供了另一个特征多态的前提。
父类的由来：其实是由多个类不断向上抽取共性内容而来的。

java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。

    单继承：一个类只能有一个父类。
    多继承：一个类可以有多个父类。
为什么不支持多继承呢？

因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。

但是java支持多重继承。A继承B  B继承C  C继承D。
多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。

所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。

简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。

子父类出现后，类中的成员都有了哪些特点：

    1：成员变量。
     当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。
     如果想要调用父类中的属性值，需要使用一个关键字：super
     This：代表是本类类型的对象引用。
    Super：代表是子类所属的父类中的内存空间引用。
     注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。
    2：成员函数。
    当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：覆盖(复写，重写)
    什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。
    3：构造函数。
    发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?
    原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super();
    super(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。
为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)

因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。

###### 注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();

如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。

如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。

问题：super()和this()是否可以同时出现的构造函数中。
两个语句只能有一个定义在第一行，所以只能出现其中一个。
super()或者this():为什么一定要定义在第一行？
因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。

继承的细节：

什么时候使用继承呢？

当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。

英文书中，所属关系：" is a "

###### 注意：不要仅仅为了获取其他类中的已有成员进行继承。所以判断所属关系，可以简单看，如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。

细节二：

在方法覆盖时，注意两点：

    1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。
    2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)
继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。

这时如何解决问题呢？介绍一个关键字，final:最终。

    final特点：
    1：这个关键字是一个修饰符，可以修饰类，方法，变量。
    2：被final修饰的类是一个最终类，不可以被继承。
    3：被final修饰的方法是一个最终方法，不可以被覆盖。
    4：被final修饰的变量是一个常量，只能赋值一次。
    其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。
    不加final修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。